# Deployment & Distribution Guide

This document outlines best practices for taking applications generated by Kybernus to production environments.

## 1. Infrastructure Requirements

Kybernus applications are designed to be environment-agnostic, running effectively in Docker containers, VMs, or serverless platforms where applicable.

### Containerization (Docker)
Every template includes optimized `Dockerfile` and `docker-compose.yml` configurations.
*   **Production Build**: Use multi-stage Docker builds (provided by default in templates like Next.js, Node.js, NestJS) to minimize image size and exclude `devDependencies`.
*   **Networking**: When deploying using the generated docker-compose, ensure production overrides are securely configured (do not expose database ports publicly unless necessary).

### Database Management
All modern Kybernus templates include robust database integrations (Prisma, SQLAlchemy, Spring Data JPA).

#### Applying Migrations in CI/CD
You must configure your deployment pipeline to run migrations against your production database **before** the new application code starts serving traffic.
*   **Node.js / Next.js / NestJS (Prisma)**:
    Ensure your CI/CD runner executes:
    ```bash
    npx prisma migrate deploy
    ```
    *Note: Do not use `migrate dev` in production.*
*   **Python (Alembic)**:
    ```bash
    alembic upgrade head
    ```
*   **Java Spring**:
    By default, Spring Boot with Hibernate can automatically update or validate the schema (via `spring.jpa.hibernate.ddl-auto`). For production, it is highly recommended to integrate a migration tool like **Flyway** or **Liquibase** into the generated `pom.xml`.

## 2. Environment Variables & Security

Proper management of environment variables is critical for Kybernus-generated apps.

### General Best Practices
*   Never commit `.env` files to version control.
*   Use environment injection at the platform level (e.g., AWS Parameter Store, Vercel Env Vars, Railway Variables).

### Critical Variables Checklist
Before launching your API, verify these variables are set in your provider:
*   `DATABASE_URL`: Your live database connection string (PostgreSQL).
*   `JWT_SECRET` / `application.security.jwt.secret-key`: A strongly generated random string for signing authentication tokens.
*   `PORT`: Ensure the app binds to the port expected by your platform (often provided automatically by PaaS providers like Heroku or Railway).
*   `NODE_ENV`: Set to `production` for Node-based templates to enable performance optimizations and disable stack traces on errors.

## 3. CI/CD Integration

If you selected "GitHub Actions" during project generation, your repository already contains a basic pipeline.

To activate deployments:
1.  **Secrets**: Add necessary secrets (like Docker Hub credentials, AWS keys, or SSH keys for direct VPS deployment) to your GitHub Repository Settings -> Secrets.
2.  **Workflow Configuration**: Review the generated `.github/workflows/deploy.yml` and adjust the deployment steps (e.g., pulling the latest image on your server or pushing to a PaaS CLI) to match your hosting provider.
